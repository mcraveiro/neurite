#+title: Sprint Backlog 10
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission

- Setup the processing pipeline in geometry.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-07-05 Tue 16:03]
| <75>                                                                        |        |      |      |       |
| Headline                                                                    | Time   |      |      |     % |
|-----------------------------------------------------------------------------+--------+------+------+-------|
| *Total time*                                                                | *4:39* |      |      | 100.0 |
|-----------------------------------------------------------------------------+--------+------+------+-------|
| Stories                                                                     | 4:39   |      |      | 100.0 |
| Active                                                                      |        | 4:39 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |        |      | 1:09 |  24.7 |
| COMPLETED Review the design changes done to geometry                        |        |      | 1:51 |  39.8 |
| STARTED Tidy-up neurite                                                     |        |      | 0:52 |  18.6 |
| STARTED Create a polygon mesh with the simple SWC file                      |        |      | 0:47 |  16.8 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-07-05 Tue 14:50]--[2016-07-05 Tue 15:09] =>  0:19
    CLOCK: [2016-07-04 Mon 17:15]--[2016-07-04 Mon 17:45] =>  0:30
    CLOCK: [2016-07-04 Mon 14:15]--[2016-07-04 Mon 14:35] =>  0:20

Updates to sprint and product backlog.

*** Journal club and lectures                                         :story:

Time spent in generic tasks.

- sorting out supervision.

*** Socialising                                                       :story:

Any events during work hours not directly connected to work.

*** Build a tree from an SWC models                                   :story:

In order to convert the SWC model into a CSG representation, we need
it to be in tree form. Create a tree builder in SWC to generate this
representation and add all associated types. Add basic tests.

*** COMPLETED Review the design changes done to geometry              :story:
    CLOSED: [2016-07-04 Mon 17:14]
    CLOCK: [2016-07-04 Mon 15:23]--[2016-07-04 Mon 17:14] =>  1:51

A number of changes were done to the geometry model to implement a
full pipeline for meshing generation. These were not completed. We
need to review and complete the design.

*** STARTED Tidy-up neurite                                           :story:
    CLOCK: [2016-07-05 Tue 15:21]--[2016-07-05 Tue 16:03] =>  0:42
    CLOCK: [2016-07-05 Tue 15:10]--[2016-07-05 Tue 15:20] =>  0:10

We've accumulated a lot of cruft:

- remove test projects for lif and ohms law, and comment out Wt
  dependencies.
- put a conditional on Qt/VTK to build soma so that the build machine
  does not build it.

*** Code-generate all models and get code to build                    :story:

We need to code-generate the models with all of the latest changes -
most likely fixing dogen errors as well - and then get the project to
compile after all of these changes. For now we should just comment out
all of the legacy code including VTK, etc.

*** Implement SWC tree factory                                        :story:

Create a simple class that takes in a SWC model and creates a tree
with operations plus solids.

*** Implement the affine transformation injector                      :story:

Create a simple injector that computes the rotations and translations
based on CSG objects. Use eigen for vector calculations.

*** Implement the tesselation executor                                :story:

We need to first implement the tesselator and then implement the
corresponding executor.

*** Implement the affine transformation executor                      :story:

Once we have polyhedra, we can start implementing the execution of the
affine transforms. This will be done by using eigen against the
polygons.

*** Implement the Nef conversion executor                             :story:

We need to first implement the Nef factory and then the conversion
executor.

*** Implement the Nef evaluator                                       :story:

Create a class responsible for evaluating the CSG operations and
merging the Nef polyhedra into a final Nef polyhedron.

*** Implement the mesher                                              :story:

Create a simple class that converts a Nef polyhedron into a CGAL mesh.

*** Create a geometry workflow for the processing pipeline            :story:

Add all available steps to the pipeline.

*** Create a command-line utility to execute geometry workflow        :story:

We need a simple wrapper for the command line that takes a SWC file
and produces an OFF file (or other mesh formats, TBD). To start off
with we can produce nothing and just use the log file to figure out
whats going on.

*** STARTED Create a polygon mesh with the simple SWC file            :story:
    CLOCK: [2016-07-04 Mon 15:18]--[2016-07-04 Mon 15:23] =>  0:05
    CLOCK: [2016-07-04 Mon 14:35]--[2016-07-04 Mon 15:17] =>  0:42

We need to create a polygon mesh representation of the simple ball and
stick SWC file.

- [[http://doc.cgal.org/latest/Mesh_3/index.html][CGAL 4.7 - 3D Mesh Generation]]

Notes:

- Delaunay refinement:
- restricted Delaunay triangulation:
- requirements on the input domain: The domain to be meshed is assumed
  to be bounded and representable as a pure 3D complex. A 3D complex
  is a set of faces with dimension 0, 1, 2 and 3 such that all faces
  are pairwise interior disjoint, and the boundary of each face of the
  complex is the union of faces of the complex. The 3D complex is
  pure, meaning that each face is included in a face of dimension 3,
  so that the complex is entirely described by the set of its 3D faces
  and their subfaces.
- output mesh: This means that each subdomain is approximated by the
  union of the tetrahedral cells whose circumcenters are located
  inside the domain (or subdomain). Each surface patch is approximated
  by the union of the Delaunay mesh facets whose dual Voronoi edges
  intersect the surface patch. Such mesh facets are called surface
  facets in the following. The 1-dimensional exposed features are
  approximated by sequences of mesh edges and the 0-dimensional
  exposed features are represented by mesh vertices.
- The mesh density refers to the number of mesh vertices and cells,
  i.e. to the complexity of the mesh. The mesh quality referred to
  here is measured by the radius edge ratio of surface facets end mesh
  cells, where the radius edge ratio of a simplex (triangle or
  tetrahedron) is the the ratio between its circumradius and its
  shortest edge.
- [[http://cgal-discuss.949826.n4.nabble.com/newbie-question-3D-meshing-of-geometric-objects-cylinder-box-etc-amp-boolean-ops-td4657492.html][Meshing of geometric objects (cylinder, box, etc) & boolean ops]]:
  CGAL allows to mesh a domain whose boundary is defined by one of
  several implicit surfaces. See the example in subsection 3.5.2 of
  chapter 3D Mesh Generation of the user manual. However if the
  surfaces intersect and if you want the mesh to precisely reproduce
  the intersection curves you have to previously detect those
  intersections.
- [[http://stackoverflow.com/questions/33197841/create-parameterized-3d-primitives-with-cgal][Create parameterized 3D primitives with cgal]]

*** Sprint review                                                     :story:

Review of the sprint.

** Deprecated
